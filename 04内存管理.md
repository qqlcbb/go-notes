# 内存管理
## 垃圾回收原理
垃圾就是不再需要的内存块，这些垃圾如果不清理就没办法再次被分配使用，在不支持垃圾回收的编程语言里，这些垃圾内存就是泄露的内存。

### 垃圾回收算法
- 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。
```
- 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。
- 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。
```
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。
```
- 优点：解决了引用计数的缺点。
- 缺点：需要STW，即要暂时停掉程序运行。
```
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。
```
- 优点：回收性能好
- 缺点：算法复杂
- 代表语言： JAVA
```

## Golang垃圾回收
垃圾回收的核心就是标记出哪些内存还在使用中(即被引用到)，哪些内存不再使用了（即未被引用），把未被引用的内存回收掉，以供后续内存分配时使用。

### 三色标记法
- 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
- 灰色：对象还在标记队列中等待
- 黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）


接着开始扫描根对象a、b、

由于根对象引用了对象A、B,那么A、B变为灰色对象，接下来就开始分析灰色对象，分析A时，A没有引用其他对象很快就转入黑色，B引用了D，则B转入黑色的同时还需要将D转为灰色，进行接下来的分析。

上图中灰色对象只有D，由于D没有引用其他对象，所以D转入黑色。
### Stop The World

对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。

Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。

## 垃圾回收优化
### 写屏障(Write Barrier)
写屏障就是让goroutine与GC同时运行的手段，可以大大减少STW的时间。
在GC的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。
### 辅助GC(Mutator Assist)
在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist。
## 垃圾回收触发时机
- 内存分配量达到阀值触发GC
- 定期触发GC，默认情况下，最长2分钟触发一次GC
- 手动触发、runtime.GC()

## GC性能优化
减少对象分配个数，比如对象复用或使用大对象组合多个小对象等等。

## 逃逸分析
指由编译器决定内存分配的位置
- 如果分配在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;

## 逃逸策略
每当函数中申请新的对象，编译器会跟据该对象是否被函数外部引用来决定是否逃逸：（对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。）
- 如果函数外部没有引用，则优先放到栈中；
- 如果函数外部存在引用，则必定放到堆中；

## 逃逸场景
- 指针逃逸（返回局部变量指针）
- 栈空间不足逃逸
- 动态类型逃逸（函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也人产生逃逸。）
- 闭包引用对象逃逸
## 逃逸总结
- 栈上分配内存比在堆中分配内存有更高的效率
- 栈上分配的内存不需要GC处理
- 堆上分配的内存使用完毕会交给GC处理
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成

函数传递指针真的比传值效率高吗？我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。