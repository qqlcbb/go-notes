# 03协程
Goroutine调度机制
## 线程池
线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中的线程不断的从任务队列中取出任务并执行，可以有效的减少线程创建和销毁所带来的开销。

如果worker线程执行的G任务中发生系统调用，则操作系统会将该线程置为阻塞状态，大部分任务都会进行系统调用，则会让这种状态恶化。

## Goroutine调度器
线程数过多，意味着操作系统会不断的切换线程，频繁的上下文切换就成了性能瓶颈。

Go提供一种机制，可以在线程中自己实现调度，上下文切换更轻量，从而达到了线程数少，而并发数并不少的效果。而线程中调度的就是Goroutine.

Goroutine主要概念如下：
- G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程。
- M（Machine）： 工作线程，在Go中称为Machine。
- P(Processor): 处理器（Go中定义的一个摡念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。

M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。

P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。

##  Goroutine调度策略
### 队列轮转
每个P维护的G队列，还有一个全局的队列，每个P会周期性的查看全局队列中是否有G待运行并将期调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性的查看全局队列，也是为了防止全局队列中的G被饿死。

### 系统调用
多出来的M将会在G产生系统调用时发挥作用，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。

当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。

### 工作量窃取
空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半。

##  GOMAXPROCS设置对性能的影响
程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。